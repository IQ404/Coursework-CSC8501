
#ifndef STATES_H_INCLUDED
#define STATES_H_INCLUDED

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include "Exception.h"
#include "SimplePolynomial.h"
#include "BasicMath.h"

class States {

public:
	void run() {
		try{
			while (true) {
				display_polynomial();
				display_options();
				choose();
			}
		} catch (const Back&) { std::cout << "Quitting the program...\n\n"; }
	}

private:

	std::vector<Rational> input_set;
	std::vector<Rational> output_set;
	SimplePolynomialSet polynomial_set;

	void display_polynomial() {
		[]() {std::cout << "\nExisting polynomials:\n"; }();
		polynomial_set.print_SimplePolynomials();
	}

	void display_options() {
		std::cout <<
			"Would you like to:\n"
			"\t1. Create a simple polynomial;\n"
			"\t2. Calculate outputs for a set of consecutive integer inputs with respect to an existing polynomial;\n"
			"\t3. Read a set of integer outputs generated by a polynomial from a file;\n"
			"\t4. Output existing polynomial(s) to a text file;\n"
			"Or enter ^Z to quit.\n\n"
			"The expression file holding the solutions to the output sets in CSC8501 coursework is named as \"expression_file.txt\" and it is located in the folder of this project.\n\n"
			"Your choice: ";
	}

	void choose() {
		char num = choice();
		if (std::cin.peek() != '\n') { std::cout << "Not an option, please try again\n"; std::string s; std::getline(std::cin, s); }
		if (std::cin.peek()) { std::string s; std::getline(std::cin, s); }
		switch (num) {
		case '1': try { create_polynomial(); } catch (const Back&) { std::cout << "Going back to main menu...\n\n"; } break;
		case '2': try { calculate_outputs(); } catch (const Back&) { std::cout << "Going back to main menu...\n\n"; } break;
		case '3': try { read_outputs(); } catch (const Back&) { std::cout << "Going back to main menu...\n\n"; } break;
		case '4': try { output_polynomial(); } catch (const Back&) { std::cout << "Going back to main menu...\n\n"; } break;
		default: std::cout << "Not an option.\n"; break;
		}
	}

	void output_polynomial() {
		if (polynomial_set.get_size() == 0) std::cout << "No existing polynoimal in the system.\n";
		else while (true) {
				std::cout << "Please enter the filepath of the text file that you want the program to write the polynomial(s) to.\n\nFilepath: ";
				std::ofstream ofs{ ask_filepath(false), std::ios_base::app };
				ofs.exceptions(ofs.exceptions() | std::ios_base::badbit);
				if (!ofs) { std::cout << "Cannot set up the output stream, please try again. (Is the filepath entered read-only??)\n"; continue; }
				for (int i = 1; i <= polynomial_set.get_size(); i++) polynomial_set.get(i).print_polynomial(ofs);
				break;
			}
	}

	char choice() {
		char c;
		while (true) {
			std::cin >> c;
			if (!std::cin) throw Back{};
			if (c == '1' || c == '2' || c == '3' || c == '4') return c;
			std::string s;
			std::getline(std::cin, s);
			std::cout << "Sorry but what was entered is not an option, please try again.\n\n";
			display_options();
		}
	}

	void print_requirements()
	{
		std::cout << "Taking in a polynomial of the form:\n\t\tP(x) = ax^4 + bx^3 + cx^2 + dx + e\n"
			"where:\n\t1. a,b,c,d are integers ranging from -9 to 9;\n"
			"\t2. e is an integer ranging from -1000 to 1000;\n"
			"\t3. At least one of a,b,c,d and e must be 0.\n\n";
	}

	bool test_stop()
	{
		char c = 0;
		if (!(std::cin >> c)) {
			std::cin.clear();
			return true;
		}
		std::cin.unget();
		return false;
	}

	void not_an_integer()
	{
		std::cin.clear();
		std::string s;
		std::getline(std::cin, s);
		std::cout << "This is not an integer, try again: (If you wish to quit, please enter ^Z)\n";
	}

	int get_coefficient(int e)
	{
		int bound = (e) ? 9 : 1000;
		while (true) {
			int coe = ask_one_integer();
			if ((-bound <= coe) && (coe <= bound)) return coe;
			std::cout << "Out of range, try again: (If you wish to quit, please enter ^Z)\n";
		}
	}

	int ask_one_integer() {
		for (int coe = 0; !test_stop(); ) {
			if (!(std::cin >> coe) || (std::cin.peek() != '\n')) {
				not_an_integer();
				continue;
			}
			return coe;
		}
		throw Back{};
	}

	bool ask_Y_N() {
		for (char ch = 0; !test_stop(); ) {
			if ((std::cin >> ch) && ((std::toupper(ch) != 'Y' && std::toupper(ch) != 'N') || (std::cin.peek() != '\n'))) {
				std::cout << "That's not an option. Please enter Y or N. (Or enter ^Z to quit)\n";
				std::string s;
				std::getline(std::cin, s);
				continue;
			}
			return (std::toupper(ch) == 'Y');
		}
		throw Back{};
	}

	bool check_coefficients(std::vector<int>& v) {
		for (auto i : v) {
			if (i == 0) return true;
		}
		std::cout << "At least 1 coefficient needs to be zero! Try again.\n";
		v.clear();
		return false;
	}

	std::vector<int> ask_for_SimplePolynomial_Coefficients()  // through std::cin & std::cout
	{
		std::vector<int> v;
		print_requirements();
		while (true) {
			for (int e = 4; e >= 0; e--) {
				std::cout << "Please enter the integer coefficient for x^" << e << ":\n";
				int p = get_coefficient(e);
				v.push_back(p);
			}
			if (check_coefficients(v)) break;
		}
		return v;
	}

	void create_polynomial() {
		std::vector<int> v = ask_for_SimplePolynomial_Coefficients();
		std::vector<Rational> u;
		for (auto i : v) u.push_back(Rational{ i });
		polynomial_set.add(SimplePolynomial{ u });
	}

	void calculate_outputs() {
		if (polynomial_set.get_size() == 0) {
			std::cout << "No polynomial exists. You need to create one first...\n\n";
			create_polynomial();
		}
		else {
			int n = choose_existing_polynomial();
			get_input_set();
			display_outputs(n);
			ask_to_save_output(n);
		}
	}

	int choose_existing_polynomial() {
		std::cout << "Choose a polynomial from the existing ones:\n";
		polynomial_set.print_SimplePolynomials();
		std::cout << "Or enter ^Z to go back to main menu.\n\nYour choice: ";
		while (true) {
			int n = ask_one_integer();
			if (n < 1 || n > polynomial_set.get_size()) { std::cout << "Sorry but what was entered is not an option. If you wish to quit, please enter ^Z. Try again:\n"; continue; }
			return n;
		}
	}

	void get_input_set() {
		input_set.clear();
		for (int i = 0; i < 2; i++) {
			std::cout << "Please enter the " << ((i == 0) ? "lower" : "upper") << " bound of your input set:\n";
			int b = ask_one_integer();
			if (i == 0) { input_set.push_back(b); continue; }
			if (i == 1 && input_set[0] > b) { std::cout << "That's an empty set! Try again:\n\n"; i = -1; input_set.clear(); }
			else if (input_set[0] == b) return;
			else for (Rational j = input_set[0] + 1; ((j < b) || (j == b)); j = j + 1) input_set.push_back(j);
		}
	}

	void display_outputs(int n) {
		output_set.clear();
		std::cout << "The outputs are:\n\n";
		for (const auto& i : input_set) {
			output_set.push_back(polynomial_set.get(n).function_value(i));
			polynomial_set.get(n).print_function_value(i);
		}
		std::cout << std::endl;
	}

	void ask_to_save_output(int i) {
		std::cout << "Would you like to save the outputs into a file? (Y/N)\nYour choice: ";
		if (!ask_Y_N()) return;
		while (true) {
			std::ofstream ofs{ ask_filepath(false), std::ios_base::app };
			ofs.exceptions(ofs.exceptions() | std::ios_base::badbit);
			if (!ofs) { std::cout << "Cannot set up the output stream, please try again. (Is the filepath entered read-only??)\n"; continue; }
			for (int i = 0; i < output_set.size(); i++) ofs << output_set[i] << ((i == output_set.size() - 1) ? "\n" : ", ");
			ask_to_output_more(&ofs, i);
			break;
		}
	}

	void ask_to_output_more(std::ofstream* ofs, int j) {
		std::cout << "Would you like to save more outputs into the file? (Y/N)\nYour choice: ";
		if (!ask_Y_N()) return;
		int n = choose_existing_polynomial();
		get_input_set();
		output_set.clear();
		for (const auto& i : input_set) output_set.push_back(polynomial_set.get(j).function_value(i));
		for (int i = 0; i < output_set.size(); i++) *ofs << output_set[i] << ((i == output_set.size() - 1) ? "\n" : ", ");
		display_outputs(j);
		ask_to_output_more(ofs, j);
	}

	std::string ask_filepath(bool input) {
		std::cout << "Please enter the pathname of the file you want the program to " << ((input) ? "read the outputs from:" : "write the outputs to:") << " (or enter ^Z to quit)\n\n"
			<< "Filepath: ";
		std::string s;
		if (std::cin.peek() == '\n') std::getline(std::cin, s);
		std::getline(std::cin, s);
		if (!std::cin) {
			std::cin.clear();
			throw Back{};
		}
		return s;
	}

	void read_outputs() {
		std::cout << "\nNote that the format of such a file should be that each output set occurs on a single line (EOL identifies the end of the output set) and that individual numbers are separated by a comma.\n"
			<< "Note also that currently this program only accepts integer outputs.\n\n"
			<< "For CSC8501 coursework, please enter \"A-F.txt\".";
		while (true) {
			std::ifstream ifs{ ask_filepath(true) };
			ifs.exceptions(ifs.exceptions() | std::ios_base::badbit);
			if (!ifs) { std::cout << "Cannot set up the input stream, please try again. (Are you sure the filepath entered really exist??)\n"; continue; }
			read_lines(&ifs);
			break;
		}
	}

	void read_lines(std::ifstream* ifs) {
		std::string s;
		std::getline(*ifs, s);
		if (!(*ifs)) { std::cout << "The file is empty.\n"; throw Back{}; }
		while (*ifs) {
			read_single_line(s);
			if (display_readings()) for (bool loop = true; loop; ) { try { find_polynomial(); loop = false; } catch (const AlgorithmFailed&) {} }
			std::getline(*ifs, s);
		}
	}

	void read_single_line(const std::string& s) {
		input_set.clear();
		std::istringstream iss{ s };
		for (int i = 0; iss >> i; ) {
			input_set.push_back(i);
			char c = 0;
			if ((iss >> c) && c != ',') { std::cout << "Encounter bad format in the file...\n"; throw Back{}; }
		}
	}

	bool display_readings() {
		std::cout << "The following outputs set has been imported:\n";
		for (const auto& i : input_set) std::cout << i << " ";
		std::cout << "\nWould you like to find the polynomial that produces these values? (Y/N)\n";
		return ask_Y_N();
	}

	void find_polynomial() {
		int c = display_method();
		if (c == 1) use_matrix();
		//TODO: c == 2 without using range values
	}

	int display_method() {
		std::cout << "Which method do you want to use to find the polynomial?\n"
			<< "\t1. Gaussian Elimination\n";
		std::cout << "\tOpps... It seems that this program can do this by Gaussian Elimination only :P\n";
		while (true) {
			int c = ask_one_integer();
			if (c != 1) { std::cout << "Not an option, please try again:\n"; continue; }
			return c;
		}
	}

	void use_matrix() {
		int end = 23;
		SimplePolynomial solution;
		for (int start = 0; start < end; start++) {
			Matrix<Rational> m;
			gaussian_elimination(start, m);
			solution = extract_polynomial(m);
			if (check_solution_range(m)) { add_polynomial_to_system(solution, m); return; }
		}
		explanation(end, solution);
		return;
	}

	void gaussian_elimination(int start, Matrix<Rational>& m) {
		make_matrix(m, start);
		m.row_reduction();
		check_matrix_solution(m, start);
	}

	void add_polynomial_to_system(SimplePolynomial& solution, const Matrix<Rational>& m) {
		std::cout << "The solution polynomial is:\n";
		solution = extract_polynomial(m);
		solution.print_polynomial(std::cout);
		polynomial_set.add(solution);
		std::cout << "This solution has been added into our system.\n\n";
	}

	void explanation(int end, SimplePolynomial& solution) {
		std::cout << "We have tried " << end << " sets of inputs but still haven't found a solution inside our solution space.\n"
			<< "One solution outside our solution space is:\n";
		solution.print_polynomial(std::cout);
		polynomial_set.add(solution);
		std::cout << "This step-back solution has been added into our system.\n\n";

		if ((end == 23) && (input_set[0] == 715) && (input_set[1] == 625) && (input_set[2] == 523) && (input_set[3] == 409) && (input_set[4] == 283)) {
			std::cout << "Actually, there is NO solution in our solution space. This is because, since the order of this polynomial is 2 and the lead term coefficient is negative, the largest polynomial-function value we"
				" can get after (and include) our trial in our solution space is -(22)^2 + 9*22 + 1000 == 714, which is smaller than the first value (715) in the current polynomial outputs set.\n\n";
		}
	}

	SimplePolynomial extract_polynomial(const Matrix<Rational>& m) {
		std::vector<Rational> v;
		for (int i = 0; i < 5; i++) {
			v.push_back(m.get_element(i, 5));
		}
		return SimplePolynomial{ v };
	}

	void make_matrix(Matrix<Rational>& m, int start) {
		for (int r = 0; r < 5; r++) {
			for (int c = 0; c < 5; c++) {
				m.set_element(r, c, power(start + r, 4 - c));
			}
		}
		for (int i = 0; (i < input_set.size() && i < 5); i++) m.set_element(i, 5, input_set[i]);
		if (input_set.size() < 5) for (int i = input_set.size(); i < 5; i++) m.set_element(i, 5, Rational{ 0 });
	}

	void check_matrix_solution(const Matrix<Rational>& m, int s) {
		SimplePolynomial sp = extract_polynomial(m);
		for (int i = s; i < s + input_set.size(); i++) {
			if (sp.function_value(i) != input_set[i - s]) { std::cout << "Gauessian Elimination found an incorrect solution, Sorry! Please try other method.\n\n"; throw AlgorithmFailed{}; }
		}
	}

	bool check_solution_range(const Matrix<Rational>& m) {
		for (int i = 0; i < 5; i++) {
			if (m.get_element(i, 5).get_denominator() != 1) return false;
		}
		for (int i = 0; i < 4; i++) {
			if (m.get_element(i, 5) < -9 || m.get_element(i, 5) > 9) return false;
		}
		if (m.get_element(4, 5) < -1000 || m.get_element(4, 5) > 1000) return false;
		return true;
	}

};

#endif // !STATES_H_INCLUDED
